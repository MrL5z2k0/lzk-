### 初始化阶段

## 1-static与final的搭配问题

**简言之，为类的静态变量赋予正确的初始值。**

1 具体描述

类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即：**到了初始化阶段，才真正开始执行类中定义的Java程序代码**。)
**初始化阶段的重要工作是执行类的初始化方法：clinit>（）方法。**

- 该方法仅能由java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。
- 它是由类静态成员的赋值语句以及static语句块合并产生的。

2 说明

2.1 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类<c1init>之前被调用。
也就是说，父类的 static块优先级高于子类。

口诀：由父及子，静态先行。

2.2 Java编译器并不会为所有的类都产生< clinit>（）初始化方法。哪些类在编译为字节码后，字节码文件中将不会包括clinit>（）方法？

- 一个类中并没有声明任何的类变量，也没有静态代码块时。
- 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。
- 一个类中包含 static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。

在链接阶段的准备环节复制的情况：

1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行。
2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行。

最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。

## 2-<clinit>()的线程安全性

对于< clinit>（）方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。

虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>（）方法，其他线程都需要阻塞等待，直到活动线程执行<c1init>（）方法完毕。

正是**因为函数<clinit>（）帯锁线程安全的**，因此，如果在一个类的<clinit>（）方法中有耗时很长的操作，就可能造成多
个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。

如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>（）方法了。那么，当需要使用这个类时,虚拟机会直接返回给它己经准备好的信息。

## 3-类的初始化情况：主动使用vs被动使用

Java程序对类的使用分为两种：主动使用和被动使用

一、主动使用

Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备己经完成。）

1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
2. 当调用类的静态方法时，即当使用了字节码 invokestatic指令
3. 当使用类、接口的静态字段时(fina修饰特殊考虑)，比如，使用 getstatic或者 putstatic指令。（对应访问变量、赋值变量操作）
4. 当使用java.lang. reflect包中的方法反射类的方法时。比如：Class. forName("com. atgulgu.java.Test")
5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
6.  如果一个接口定义了 default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化
7. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main（）方法的那个类），虚拟机会先初始化这个主类。
8. 当初次调用 Methodhandle实例时，初始化该 Methodhandle指向的方法所在的类。（涉及解析REF_ getstatic、REF_ putstatic、REF_ invokestatic方法句柄对应的类）

对5,补充说明
当]ava虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。
在初始化一个类时，并不会先初始化它所实现的接口

类的初始化情况：主动使用vs被动使用
Java程序对类的使用分为两种：主动使用和被动使用

一、主动使用
Class只有在必须要首次使用的时候オ会被装载，Java虚拟机不会无条件地装载Ccass类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备己经完成。）

1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
2. 当调用类的静态方法时，即当使用了字节码 invokestatic指令。
3. 当使用类、接口的静态字段时(fina1修饰特殊考虑)，比如，使用 getstatic或者 putstatic指令。（对应访问变量
   、赋值变量操作）
4. 当使用java.1ang. reflect包中的方法反射类的方法时。比如：Class. forname("com. atguigu,java.Test")
5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
6. 如果一个接口定义了 default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。
7. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main（）方法的那个类），虚拟机会先初始化这个主类。
8. 当初次调用 Methodhandle实例时，初始化该 Methodhandle指向的方法所在的类。（涉及解析REF_ getstatic、REF_ putstatic、REF_ invokestatic方法句柄对应的类）

针对5,补充说明：
当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。
在初始化一个类时，并不会先初始化它所实现的接口。

针对7 说明：
JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main( String [])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。

二、被动使用
除了以上的情况属于主动使用，其他的情况均属于被动使用。**被动使用不会引起类的初始化。**
也就是说：**并不是在代码中出现的类，就一定会被加载或者初始化。果不符合主如动使用的条件，类就不会初始**。

1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化
2. 通过数组定义类引用，不会触发此类的初始化
3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。
4. 调用classloader类的loadClass（）方法加载一个类，并不是对类的主动使用，不会导致类的初始化。
   
