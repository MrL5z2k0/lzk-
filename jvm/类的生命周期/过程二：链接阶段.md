# 链接阶段

## 1-环节1：验证阶段

当类加载到系统后，就开始链接操作，验证是链接操作的第一步。 

它的目的是保证加载的字节码是合法、合理并符合规范的。 

验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检査，如图所示。

![image-20210328162609172](C:\Users\93138\AppData\Roaming\Typora\typora-user-images\image-20210328162609172.png)

整体说明：
验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。

- 其中**格式验证会和加载阶段一起执行**。验证通过之后，类加载器オ会成功将类的二进制数据信息加载到方法区中。
- **格式验证之外的验证操作将会在方法区中进行**

链接阶段的验证虽然拖慢了加载速度但是它免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）

具体说明：

1. 格式验证：是否以魔数 OXCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等

2. Java拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：

   - 是否所有的类都有父类的存在(在Java里，除了 object外，其他类都应该有父类)

   - 是否一些被定义为finaL的方法或者类被重写或继承了

   - 非抽象类是否实现了所有抽象方法或者接口方法

   - 是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度； abstract情况下的方法，就不能是fina的了）

3. Java虚拟机还会进行字节码验证，**字节码验证也是验证过程中最为复杂的一个过程**。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：

   - 在字节码的执行过程中，是否会跳转到一条不存在的指令

   - 函数的调用是否传递了正确类型的参数

   - 变量的赋值是不是给了正确的数据类型等

   栈映射帧( StackMaptable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。
   但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检査出可以预知的明显
   的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的

**在前面3次检查中，已经派出了文件格式错误、予以错误以及字节码的不正确性。但是依然不能保证类时没有问题的。**

​	4.校验器还将进行符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，**虚拟机就会检查这些类或者方法确实时存在的**，并且当前有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。

此阶段在解析环节才会执行。



## 2-环节2：准备阶段

**准备阶段( Preparation),简言之，为类的静态变量分配内存，并将其初始化为默认值。**

当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。 java虚拟机为各类型变量默认的初始值如表所示。

![image-20210328164938644](C:\Users\93138\AppData\Roaming\Typora\typora-user-images\image-20210328164938644.png)

注意：Java并不支持 boolean类型，对于 boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。

注意：

1. **这里不包含基本数据类型的字段用 static final修饰的情況，因为final在编译的时候就会分配了，准备阶段会显式赋值。**
2. 注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
3. 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行

基本数据类型：非final修饰的变量，在准备环节进行默认初始化赋值。final修饰以后，在准备环节直接进行显示赋值。

扩展：如果使用**字面量**的方式定义一个字符串的常量的话，也是在准备环节直接进行显示赋值。

## 3-环节3：链接阶段之解析

**解析阶段( Resolution),简言之，将类、接口、字段和方法的符号引用转为直接引用。**

1 具体描述
符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 printin（）方法被调用时，系统需要明确知道该方法的位置。
举例：输出操作 System,out. printin（）对应的字节码
invokevirtual #24 <java/io/Printstream println>
![image-20210401211638346](C:\Users\93138\AppData\Roaming\Typora\typora-user-images\image-20210401211638346.png)

以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时位 只要知道这个方法在方法表中的偏移量就可以直接调用该方法。**通过解析操作，符号引用就可以转变为目标方法在类 中方法表中的位置，从而使得方法被成功调用。**

2 小结：
所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果
直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。

不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 Hotspot VM中，加载、验证、准备和初始化会
按照顺序有条不素地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。

3 字符串的复习
最后，再来看一下 CONSTANT_ String的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下
String在Java虚拟机中的处理。**当在Java代码中直接使用字符串量时，就会在类中出现 CONSTANT_ String**，它表示
字符串常量，并且会引用一个 CONSTANT_UTF8的常量项。**在Java虚拟行中的常量池中，会维护一张字符串拘留表( intern),它会保存所有出现过的字符串常量，井且没有重复项。**只要以 CONSTANT_ String形式出现的字符串也都会在这张表中。使用 String. intern（）方法可以得到一个字行串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的 String.intern（）方法返回总是相等的。
