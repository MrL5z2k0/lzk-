# 类的加载

## 1 类的加载过程

在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。
按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段。

![image-20210328153411246](https://github.com/MrL5z2k0/zkNode/blob/main/images/image-20210328153411246.png)

其中，验证、准备、解析3个部分统称为链接( Linking)

从程序中类的使用过程看：

![image-20210328153904085](https://github.com/MrL5z2k0/zkNode/blob/main/images/image-20210328153904085.png)

初始化之后就会在方法区中存放这个类的模板。

### 1.1加载阶段

#### 1.1.1记载完成的操作

加载的理解
**所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型ー一类模板对象。**所
谓类模板对象，其实就是Java类JVM内存中的一个快照JVMM将从字节码文件中解析出的常量池、类字段、类方法等信息
存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能
进行Java方法的调用。
反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。

加载完成的操作
**加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。**
在加载类时，Java虚拟机必须完成以下3件事情；
通过类的全名，获取类的二进制数据流。
解析类的二进制数据流为方法区内的数据结构(Java类模型)
创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口

#### 1.1.2 二进制流的获取方式

对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。(只要所读取的字节码符合JVM规范即可)

- 虚拟机可能通过文件系统读入一个class后缀的文件（最常见）
- 读入jar、zip等归档数据包，提取类文件。
- 事先存放在数据库中的类的二进制数
- 使用类似于HTP之类的协议通过网络进行加载
- 在运行时生成一段Class的二进制信息等

在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。

在方法区中类模板数据，堆中创建大的class实例指向方法区的整个类模板数据。

如果输入数据不是Classfilel的结构，则会抛出Classformaterror。

#### 1.1.3 类模型与Class实例的位置

1. 类模型的位置
   加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前：永久代：JDK1.8及之后：元空间)。

2. Class实例的位置
   类将.class文件加载至元空间后，会在堆中创建一个]ava.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass  --> mirror : Class的实例）

3.  外部可以通过访问代表Order类的class对象来获取 Orderl的类数据结构。

   ![image-20210328160701958](https://github.com/MrL5z2k0/zkNode/blob/main/images/image-20210328160701958.png)

4. Class类的构造方法是私有的，只有JVM能够创建。 

java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联.class文件中具体的数据结构：方法、字段等信息。

#### 1.1.4 数组类的加载

创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类(下述简称A)的过程：

1. 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型
2. JVM使用指定的元素类型和数组维度来创建新的数组类。

如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为Public。